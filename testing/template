# src/utils/decorators.py
from functools import wraps
from flask import request, jsonify

def auth_required(f):
    """
    Generic authentication decorator
    Implement your authentication verification logic
    """
    @wraps(f)
    def decorated(*args, **kwargs):
        # Placeholder for authentication verification
        # Implement your auth token/session validation logic
        auth_header = request.headers.get('Authorization')
        if not auth_header:
            return jsonify({'message': 'Authentication required'}), 401

        try:
            # Placeholder: Verify authentication and get user
            # Replace with your authentication mechanism
            current_user = None  # Implement user retrieval based on auth
            if not current_user:
                return jsonify({'message': 'Invalid authentication'}), 401
            return f(current_user, *args, **kwargs)
        except Exception as e:
            return jsonify({'message': 'Authentication failed'}), 401

    return decorated

def permission_required(permission):
    """
    Generic permission decorator
    Args:
        permission: Required permission/role
    """
    def decorator(f):
        @wraps(f)
        def decorated(*args, **kwargs):
            # Placeholder for permission verification
            # Implement your authorization logic
            try:
                # Verify user permissions/roles
                pass
            except Exception as e:
                return jsonify({'message': 'Permission denied'}), 403
            return f(*args, **kwargs)
        return decorated
    return decorator
```````````````````````

# src/utils/exceptions.py
from flask import jsonify

class APIError(Exception):
    """Custom API Exception"""
    def __init__(self, message, status_code=400):
        self.message = message
        self.status_code = status_code

def register_error_handlers(app):
    """Register error handlers for the application"""

    @app.errorhandler(APIError)
    def handle_api_error(error):
        return jsonify({'message': error.message}), error.status_code

    @app.errorhandler(404)
    def not_found_error(error):
        return jsonify({'message': 'Resource not found'}), 404

    @app.errorhandler(500)
    def internal_error(error):
        return jsonify({'message': 'Internal server error'}), 500

``````````````````````````````````````````

# src/services/user_service.py
class UserService:
    """
    User Service class for handling user-related operations.
    Implement your preferred data storage and authentication mechanism.
    """

    def authenticate_user(self, credentials):
        """
        Authenticate a user with given credentials
        Args:
            credentials: Dict containing authentication credentials
        Returns:
            dict: Authentication result with token/session info
        """
        # Placeholder for authentication implementation
        # Implement your authentication logic (OAuth, JWT, Session, etc.)
        raise NotImplementedError("Authentication method not implemented")

    def get_user_by_id(self, user_id):
        """
        Retrieve user by ID
        Args:
            user_id: User identifier
        Returns:
            dict: User information
        """
        # Placeholder for user retrieval implementation
        raise NotImplementedError("User retrieval method not implemented")

    def update_user(self, user_id, data):
        """
        Update user data
        Args:
            user_id: User identifier
            data: Dict containing update data
        Returns:
            dict: Update operation result
        """
        # Placeholder for user update implementation
        raise NotImplementedError("User update method not implemented")
`````````````````````````````````

# src/routes/user_routes.py
from flask import Blueprint, request, jsonify
from src.services.user_service import UserService
from src.utils.decorators import auth_required

user_bp = Blueprint('user', __name__)
user_service = UserService()

@user_bp.route('/auth', methods=['POST'])
def authenticate():
    """Authentication endpoint"""
    credentials = request.get_json()
    result = user_service.authenticate_user(credentials)
    return jsonify(result)

@user_bp.route('/profile', methods=['GET'])
@auth_required
def get_profile(current_user):
    """Profile retrieval endpoint"""
    return jsonify(current_user)

@user_bp.route('/update', methods=['PUT'])
@auth_required
@permission_required('admin')
def update_profile(current_user):
    """Profile update endpoint"""
    data = request.get_json()
    result = user_service.update_user(current_user['id'], data)
    return jsonify(result)



flask_api/
│
├── src/
│   ├── config/
│   │   ├── __init__.py
│   │   └── settings.py
│   │
│   ├── routes/
│   │   ├── __init__.py
│   │   ├── user_routes.py
│   │   └── admin_routes.py
│   │
│   ├── services/
│   │   ├── __init__.py
│   │   ├── user_service.py
│   │   └── admin_service.py
│   │
│   └── utils/
│       ├── __init__.py
│       ├── app_init.py
│       ├── decorators.py
│       └── exceptions.py
│
├── api.py
└── requirements.txt


import re
import json
import xml.dom.minidom
import xml.etree.ElementTree as ET
import os

def read_markdown_file(file_path):
    """Read the markdown file content."""
    with open(file_path, 'r', encoding='utf-8') as file:
        return file.read()

def parse_markdown_to_dict(markdown_content):
    """Parse markdown content to a structured dictionary."""
    lines = markdown_content.split('\n')
    brd_dict = {
        "BusinessRequirementsDocument": {
            "FunctionalRequirements": {
                "StreamlituIPages": {
                    "Page": []
                }
            },
            "LibrariesToUse": {
                "Library": []
            }
        }
    }

    current_section = None
    current_subsection = None
    current_page = None
    current_requirement = None
    in_libraries = False

    for line in lines:
        line = line.strip()
        if not line:
            continue

        # Main sections (h1 or h2)
        if line.startswith('# '):
            current_section = line[2:].strip()
            current_subsection = None
            current_page = None
            current_requirement = None
            in_libraries = False

        # Subsections (h2)
        elif line.startswith('## '):
            current_subsection = line[3:].strip()
            current_page = None
            current_requirement = None
            in_libraries = False

            if current_subsection == "Project":
                brd_dict["BusinessRequirementsDocument"]["Project"] = ""
            elif current_subsection == "Version":
                brd_dict["BusinessRequirementsDocument"]["Version"] = ""
            elif current_subsection == "Date":
                brd_dict["BusinessRequirementsDocument"]["Date"] = ""
            elif current_subsection == "Author":
                brd_dict["BusinessRequirementsDocument"]["Author"] = ""
            elif current_subsection == "Stakeholders":
                brd_dict["BusinessRequirementsDocument"]["Stakeholders"] = ""
            elif current_subsection == "Overview":
                brd_dict["BusinessRequirementsDocument"]["Overview"] = {"Description": ""}
            elif current_subsection == "Functional Requirements":
                current_subsection = "FunctionalRequirements"
            elif current_subsection == "Libraries to Use":
                in_libraries = True

        # Sub-subsections (h3)
        elif line.startswith('### '):
            subsub_section = line[4:].strip()
            if current_subsection == "FunctionalRequirements":
                if subsub_section == "Menu Title":
                    brd_dict["BusinessRequirementsDocument"]["FunctionalRequirements"]["MenuTitle"] = ""
                elif subsub_section == "Streamlit UI Pages":
                    current_subsection = "StreamlituIPages"

        # Sub-sub-subsections (h4)
        elif line.startswith('#### '):
            page_name = line[5:].strip()
            if current_subsection == "StreamlituIPages":
                current_page = {
                    "Name": page_name,
                    "Description": "",
                    "Requirements": []
                }
                brd_dict["BusinessRequirementsDocument"]["FunctionalRequirements"]["StreamlituIPages"]["Page"].append(current_page)
                current_requirement = None

        # Content lines
        elif line.startswith('- **') and line.endswith('**'):
            # Extract content between ** markers
            content = line[3:-2].strip()
            key_value = content.split('**: ', 1)

            if len(key_value) == 2:
                key, value = key_value

                if current_subsection == "Project" and key == "PO Upload Web Application":
                    brd_dict["BusinessRequirementsDocument"]["Project"] = value
                elif current_subsection == "Version" and key == "1.0":
                    brd_dict["BusinessRequirementsDocument"]["Version"] = value
                elif current_subsection == "Date" and key == "2025-02-19":
                    brd_dict["BusinessRequirementsDocument"]["Date"] = value
                elif current_subsection == "Author":
                    brd_dict["BusinessRequirementsDocument"]["Author"] = value
                elif current_subsection == "Stakeholders":
                    brd_dict["BusinessRequirementsDocument"]["Stakeholders"] = value
                elif current_subsection == "Overview" and key == "Description":
                    brd_dict["BusinessRequirementsDocument"]["Overview"]["Description"] = value
                elif current_subsection == "FunctionalRequirements" and key == "PO Validations":
                    brd_dict["BusinessRequirementsDocument"]["FunctionalRequirements"]["MenuTitle"] = value
                elif current_page is not None and key == "Description":
                    current_page["Description"] = value

        # Requirements (bullet points)
        elif line.startswith('- ') and current_page is not None:
            requirement_text = line[2:].strip()
            if not requirement_text.startswith('**'):  # Skip metadata lines
                requirement = {"Requirement": requirement_text, "Conditions": []}
                current_page["Requirements"].append(requirement)
                current_requirement = requirement

        # Conditions (sub-bullet points)
        elif line.startswith('    - ') and current_requirement is not None:
            condition_text = line[6:].strip()
            current_requirement["Conditions"].append(condition_text)

        # Libraries
        elif line.startswith('- `') and in_libraries:
            library = line[3:].strip().strip('`')
            brd_dict["BusinessRequirementsDocument"]["LibrariesToUse"]["Library"].append(library)

    # Post-processing: fix the structure for pages and requirements
    pages = brd_dict["BusinessRequirementsDocument"]["FunctionalRequirements"]["StreamlituIPages"]["Page"]
    for page in pages:
        requirements_list = []
        for req in page["Requirements"]:
            requirement_dict = {"Requirement": req["Requirement"]}
            if req["Conditions"]:
                conditions_list = []
                for condition in req["Conditions"]:
                    conditions_list.append({"Condition": condition})
                requirement_dict["Conditions"] = conditions_list
            requirements_list.append(requirement_dict)
        page["Requirements"] = {"Requirement": requirements_list}

    return brd_dict

def dict_to_xml(dict_data):
    """Convert dictionary to XML."""
    root = ET.Element("BusinessRequirementsDocument")

    # Add simple elements
    for key in ["Project", "Version", "Date", "Author", "Stakeholders"]:
        if key in dict_data["BusinessRequirementsDocument"]:
            element = ET.SubElement(root, key)
            element.text = dict_data["BusinessRequirementsDocument"][key]

    # Add Overview
    if "Overview" in dict_data["BusinessRequirementsDocument"]:
        overview = ET.SubElement(root, "Overview")
        description = ET.SubElement(overview, "Description")
        description.text = dict_data["BusinessRequirementsDocument"]["Overview"]["Description"]

    # Add Functional Requirements
    if "FunctionalRequirements" in dict_data["BusinessRequirementsDocument"]:
        func_reqs = ET.SubElement(root, "FunctionalRequirements")

        # Add Menu Title
        if "MenuTitle" in dict_data["BusinessRequirementsDocument"]["FunctionalRequirements"]:
            menu_title = ET.SubElement(func_reqs, "MenuTitle")
            menu_title.text = dict_data["BusinessRequirementsDocument"]["FunctionalRequirements"]["MenuTitle"]

        # Add Streamlit UI Pages
        if "StreamlituIPages" in dict_data["BusinessRequirementsDocument"]["FunctionalRequirements"]:
            ui_pages = ET.SubElement(func_reqs, "StreamlituIPages")

            # Add Pages
            for page_data in dict_data["BusinessRequirementsDocument"]["FunctionalRequirements"]["StreamlituIPages"]["Page"]:
                page = ET.SubElement(ui_pages, "Page")

                # Add Page Name
                name = ET.SubElement(page, "Name")
                name.text = page_data["Name"]

                # Add Page Description
                description = ET.SubElement(page, "Description")
                description.text = page_data["Description"]

                # Add Requirements
                requirements = ET.SubElement(page, "Requirements")

                for req_data in page_data["Requirements"]["Requirement"]:
                    requirement = ET.SubElement(requirements, "Requirement")
                    requirement.text = req_data["Requirement"]

                    # Add Conditions if present
                    if "Conditions" in req_data:
                        for condition_data in req_data["Conditions"]:
                            condition = ET.SubElement(requirement, "Condition")
                            condition.text = condition_data["Condition"]

    # Add Libraries to Use
    if "LibrariesToUse" in dict_data["BusinessRequirementsDocument"]:
        libraries = ET.SubElement(root, "LibrariesToUse")

        for lib in dict_data["BusinessRequirementsDocument"]["LibrariesToUse"]["Library"]:
            library = ET.SubElement(libraries, "Library")
            library.text = lib

    # Convert to string and pretty print
    rough_string = ET.tostring(root, 'utf-8')
    reparsed = xml.dom.minidom.parseString(rough_string)
    return reparsed.toprettyxml(indent="\t")

def main():
    # Find the BRD markdown file in the current directory
    brd_files = [f for f in os.listdir('.') if f.endswith('.md') and 'BRD' in f.upper()]

    if not brd_files:
        print("No BRD markdown file found in the current directory.")
        return

    brd_file = brd_files[0]
    print(f"Processing {brd_file}...")

    # Read markdown content
    markdown_content = read_markdown_file(brd_file)

    # Parse markdown to dictionary
    brd_dict = parse_markdown_to_dict(markdown_content)

    # Save JSON file
    json_file = brd_file.replace('.md', '.json')
    with open(json_file, 'w', encoding='utf-8') as f:
        json.dump(brd_dict, f, indent=2)
    print(f"JSON file saved as {json_file}")

    # Convert dictionary to XML
    xml_content = dict_to_xml(brd_dict)

    # Save XML file
    xml_file = brd_file.replace('.md', '.xml')
    with open(xml_file, 'w', encoding='utf-8') as f:
        f.write(xml_content)
    print(f"XML file saved as {xml_file}")

if __name__ == "__main__":
    main()

# Created/Modified files during execution:
# BRD.json
# BRD.xml




``````````````````````````````

import re
import json
import xml.dom.minidom
import xml.etree.ElementTree as ET
import os

def read_markdown_file(file_path):
    """Read the markdown file content."""
    with open(file_path, 'r', encoding='utf-8') as file:
        return file.read()

def parse_markdown_to_dict(markdown_content):
    """Parse markdown content to a structured dictionary."""
    lines = markdown_content.split('\n')
    brd_dict = {
        "BusinessRequirementsDocument": {
            "FunctionalRequirements": {
                "StreamlituIPages": {
                    "Page": []
                }
            },
            "LibrariesToUse": {
                "Library": []
            }
        }
    }

    current_section = None
    current_subsection = None
    current_page = None
    current_requirement = None
    in_libraries = False

    i = 0
    while i < len(lines):
        line = lines[i].strip()

        # Skip empty lines
        if not line:
            i += 1
            continue

        # Main sections (h1)
        if line.startswith('# '):
            current_section = line[2:].strip()
            current_subsection = None
            current_page = None
            current_requirement = None
            in_libraries = False
            i += 1
            continue

        # Subsections (h2)
        if line.startswith('## '):
            current_subsection = line[3:].strip()
            current_page = None
            current_requirement = None

            # Check next line for content
            next_line_index = i + 1
            while next_line_index < len(lines) and not lines[next_line_index].strip():
                next_line_index += 1

            if next_line_index < len(lines):
                next_line = lines[next_line_index].strip()

                if current_subsection == "Project":
                    if next_line.startswith('- **'):
                        value = next_line.split('**', 2)[1].strip()
                        brd_dict["BusinessRequirementsDocument"]["Project"] = value
                elif current_subsection == "Version":
                    if next_line.startswith('- **'):
                        value = next_line.split('**', 2)[1].strip()
                        brd_dict["BusinessRequirementsDocument"]["Version"] = value
                elif current_subsection == "Date":
                    if next_line.startswith('- **'):
                        value = next_line.split('**', 2)[1].strip()
                        brd_dict["BusinessRequirementsDocument"]["Date"] = value
                elif current_subsection == "Author":
                    if next_line.startswith('- **'):
                        value = next_line.split('**', 2)[1].strip()
                        brd_dict["BusinessRequirementsDocument"]["Author"] = value
                elif current_subsection == "Stakeholders":
                    if next_line.startswith('- **'):
                        value = next_line.split('**', 2)[1].strip()
                        brd_dict["BusinessRequirementsDocument"]["Stakeholders"] = value
                elif current_subsection == "Overview":
                    if next_line.startswith('- **Description**'):
                        desc_line = next_line.split(': ', 1)
                        if len(desc_line) > 1:
                            brd_dict["BusinessRequirementsDocument"]["Overview"] = {"Description": desc_line[1].strip()}
                elif current_subsection == "Functional Requirements":
                    current_subsection = "FunctionalRequirements"
                elif current_subsection == "Libraries to Use":
                    in_libraries = True

            i += 1
            continue

        # Sub-subsections (h3)
        if line.startswith('### '):
            subsub_section = line[4:].strip()
            if current_subsection == "FunctionalRequirements":
                if subsub_section == "Menu Title":
                    # Check next line for content
                    next_line_index = i + 1
                    while next_line_index < len(lines) and not lines[next_line_index].strip():
                        next_line_index += 1

                    if next_line_index < len(lines):
                        next_line = lines[next_line_index].strip()
                        if next_line.startswith('- **'):
                            value = next_line.split('**', 2)[1].strip()
                            brd_dict["BusinessRequirementsDocument"]["FunctionalRequirements"]["MenuTitle"] = value
                elif subsub_section == "Streamlit UI Pages":
                    current_subsection = "StreamlituIPages"

            i += 1
            continue

        # Sub-sub-subsections (h4)
        if line.startswith('#### '):
            page_name = line[5:].strip()
            if current_subsection == "StreamlituIPages":
                current_page = {
                    "Name": page_name,
                    "Description": "",
                    "Requirements": []
                }
                brd_dict["BusinessRequirementsDocument"]["FunctionalRequirements"]["StreamlituIPages"]["Page"].append(current_page)
                current_requirement = None

            i += 1
            continue

        # Content lines for page description
        if line.startswith('- **Description**') and current_page is not None:
            desc_parts = line.split(': ', 1)
            if len(desc_parts) > 1:
                current_page["Description"] = desc_parts[1].strip()

            i += 1
            continue

        # Requirements (bullet points)
        if line.startswith('- ') and current_page is not None and not line.startswith('- **'):
            requirement_text = line[2:].strip()
            requirement = {"Requirement": requirement_text, "Conditions": []}
            current_page["Requirements"].append(requirement)
            current_requirement = requirement

            i += 1
            continue

        # Conditions (sub-bullet points)
        if line.startswith('    - ') and current_requirement is not None:
            condition_text = line[6:].strip()
            current_requirement["Conditions"].append(condition_text)

            i += 1
            continue

        # Libraries
        if line.startswith('- `') and in_libraries:
            library = line[3:].strip().strip('`')
            brd_dict["BusinessRequirementsDocument"]["LibrariesToUse"]["Library"].append(library)

            i += 1
            continue

        # If none of the above conditions match, move to the next line
        i += 1

    # Post-processing: fix the structure for pages and requirements
    pages = brd_dict["BusinessRequirementsDocument"]["FunctionalRequirements"]["StreamlituIPages"]["Page"]
    for page in pages:
        requirements_list = []
        for req in page["Requirements"]:
            requirement_dict = {"Requirement": req["Requirement"]}
            if req["Conditions"]:
                conditions_list = []
                for condition in req["Conditions"]:
                    conditions_list.append({"Condition": condition})
                requirement_dict["Conditions"] = conditions_list
            requirements_list.append(requirement_dict)
        page["Requirements"] = {"Requirement": requirements_list}

    return brd_dict

def dict_to_xml(dict_data):
    """Convert dictionary to XML."""
    root = ET.Element("BusinessRequirementsDocument")

    # Add simple elements
    for key in ["Project", "Version", "Date", "Author", "Stakeholders"]:
        if key in dict_data["BusinessRequirementsDocument"]:
            element = ET.SubElement(root, key)
            element.text = dict_data["BusinessRequirementsDocument"][key]

    # Add Overview
    if "Overview" in dict_data["BusinessRequirementsDocument"]:
        overview = ET.SubElement(root, "Overview")
        description = ET.SubElement(overview, "Description")
        description.text = dict_data["BusinessRequirementsDocument"]["Overview"]["Description"]

    # Add Functional Requirements
    if "FunctionalRequirements" in dict_data["BusinessRequirementsDocument"]:
        func_reqs = ET.SubElement(root, "FunctionalRequirements")

        # Add Menu Title
        if "MenuTitle" in dict_data["BusinessRequirementsDocument"]["FunctionalRequirements"]:
            menu_title = ET.SubElement(func_reqs, "MenuTitle")
            menu_title.text = dict_data["BusinessRequirementsDocument"]["FunctionalRequirements"]["MenuTitle"]

        # Add Streamlit UI Pages
        if "StreamlituIPages" in dict_data["BusinessRequirementsDocument"]["FunctionalRequirements"]:
            ui_pages = ET.SubElement(func_reqs, "StreamlituIPages")

            # Add Pages
            for page_data in dict_data["BusinessRequirementsDocument"]["FunctionalRequirements"]["StreamlituIPages"]["Page"]:
                page = ET.SubElement(ui_pages, "Page")

                # Add Page Name
                name = ET.SubElement(page, "Name")
                name.text = page_data["Name"]

                # Add Page Description
                description = ET.SubElement(page, "Description")
                description.text = page_data["Description"]

                # Add Requirements
                requirements = ET.SubElement(page, "Requirements")

                for req_data in page_data["Requirements"]["Requirement"]:
                    requirement = ET.SubElement(requirements, "Requirement")
                    requirement.text = req_data["Requirement"]

                    # Add Conditions if present
                    if "Conditions" in req_data:
                        for condition_data in req_data["Conditions"]:
                            condition = ET.SubElement(requirement, "Condition")
                            condition.text = condition_data["Condition"]

    # Add Libraries to Use
    if "LibrariesToUse" in dict_data["BusinessRequirementsDocument"]:
        libraries = ET.SubElement(root, "LibrariesToUse")

        for lib in dict_data["BusinessRequirementsDocument"]["LibrariesToUse"]["Library"]:
            library = ET.SubElement(libraries, "Library")
            library.text = lib

    # Convert to string and pretty print
    rough_string = ET.tostring(root, 'utf-8')
    reparsed = xml.dom.minidom.parseString(rough_string)
    return reparsed.toprettyxml(indent="\t")

def main():
    # Find the BRD markdown file in the current directory
    brd_files = [f for f in os.listdir('.') if f.endswith('.md') and 'BRD' in f.upper()]

    if not brd_files:
        print("No BRD markdown file found in the current directory.")
        return

    brd_file = brd_files[0]
    print(f"Processing {brd_file}...")

    # Read markdown content
    markdown_content = read_markdown_file(brd_file)

    # Parse markdown to dictionary
    brd_dict = parse_markdown_to_dict(markdown_content)

    # Save JSON file
    json_file = brd_file.replace('.md', '.json')
    with open(json_file, 'w', encoding='utf-8') as f:
        json.dump(brd_dict, f, indent=2)
    print(f"JSON file saved as {json_file}")

    # Convert dictionary to XML
    xml_content = dict_to_xml(brd_dict)

    # Save XML file
    xml_file = brd_file.replace('.md', '.xml')
    with open(xml_file, 'w', encoding='utf-8') as f:
        f.write(xml_content)
    print(f"XML file saved as {xml_file}")

if __name__ == "__main__":
    main()

# Created/Modified files during execution:
# BRD.json
# BRD.xml


`````````````````````````````
import re
import json
import xml.dom.minidom
import xml.etree.ElementTree as ET
import os

def read_markdown_file(file_path):
    """Read the markdown file content."""
    with open(file_path, 'r', encoding='utf-8') as file:
        return file.read()

def parse_markdown_to_dict(markdown_content):
    """Parse markdown content to a structured dictionary."""
    lines = markdown_content.split('\n')
    brd_dict = {
        "BusinessRequirementsDocument": {
            "Project": "",
            "Version": "",
            "Date": "",
            "Author": "",
            "Stakeholders": "",
            "Overview": {
                "Description": ""
            },
            "FunctionalRequirements": {
                "MenuTitle": "",
                "StreamlituIPages": {
                    "Page": []
                }
            },
            "LibrariesToUse": {
                "Library": []
            }
        }
    }

    current_section = None
    current_subsection = None
    current_page = None
    current_requirement = None
    in_libraries = False
    in_column_specific = False

    i = 0
    while i < len(lines):
        line = lines[i].strip()

        # Skip empty lines
        if not line:
            i += 1
            continue

        # Main sections (h1)
        if line.startswith('# '):
            current_section = line[2:].strip()
            current_subsection = None
            current_page = None
            current_requirement = None
            in_libraries = False
            in_column_specific = False
            i += 1
            continue

        # Subsections (h2)
        if line.startswith('## '):
            current_subsection = line[3:].strip()
            current_page = None
            current_requirement = None
            in_column_specific = False

            # Check next line for content
            next_line_index = i + 1
            while next_line_index < len(lines) and not lines[next_line_index].strip():
                next_line_index += 1

            if next_line_index < len(lines):
                next_line = lines[next_line_index].strip()

                if current_subsection == "Project":
                    if next_line.startswith('- **'):
                        value = next_line.split('**:', 1)[1].strip() if '**:' in next_line else next_line.split('**', 2)[1].strip()
                        brd_dict["BusinessRequirementsDocument"]["Project"] = value
                elif current_subsection == "Version":
                    if next_line.startswith('- **'):
                        value = next_line.split('**:', 1)[1].strip() if '**:' in next_line else next_line.split('**', 2)[1].strip()
                        brd_dict["BusinessRequirementsDocument"]["Version"] = value
                elif current_subsection == "Date":
                    if next_line.startswith('- **'):
                        value = next_line.split('**:', 1)[1].strip() if '**:' in next_line else next_line.split('**', 2)[1].strip()
                        brd_dict["BusinessRequirementsDocument"]["Date"] = value
                elif current_subsection == "Author":
                    if next_line.startswith('- **'):
                        value = next_line.split('**:', 1)[1].strip() if '**:' in next_line else next_line.split('**', 2)[1].strip()
                        brd_dict["BusinessRequirementsDocument"]["Author"] = value
                elif current_subsection == "Stakeholders":
                    if next_line.startswith('- **'):
                        value = next_line.split('**:', 1)[1].strip() if '**:' in next_line else next_line.split('**', 2)[1].strip()
                        brd_dict["BusinessRequirementsDocument"]["Stakeholders"] = value
                elif current_subsection == "Overview":
                    if next_line.startswith('- **Description**'):
                        desc_line = next_line.split(': ', 1)
                        if len(desc_line) > 1:
                            brd_dict["BusinessRequirementsDocument"]["Overview"]["Description"] = desc_line[1].strip()
                elif current_subsection == "Functional Requirements":
                    current_subsection = "FunctionalRequirements"
                elif current_subsection == "Libraries to Use":
                    in_libraries = True

            i += 1
            continue

        # Sub-subsections (h3)
        if line.startswith('### '):
            subsub_section = line[4:].strip()
            if current_subsection == "FunctionalRequirements":
                if subsub_section == "Menu Title":
                    # Check next line for content
                    next_line_index = i + 1
                    while next_line_index < len(lines) and not lines[next_line_index].strip():
                        next_line_index += 1

                    if next_line_index < len(lines):
                        next_line = lines[next_line_index].strip()
                        if next_line.startswith('- **'):
                            value = next_line.split('**:', 1)[1].strip() if '**:' in next_line else next_line.split('**', 2)[1].strip()
                            brd_dict["BusinessRequirementsDocument"]["FunctionalRequirements"]["MenuTitle"] = value
                elif subsub_section == "Streamlit UI Pages":
                    current_subsection = "StreamlituIPages"

            i += 1
            continue

        # Sub-sub-subsections (h4)
        if line.startswith('#### '):
            page_name = line[5:].strip()
            if current_subsection == "StreamlituIPages":
                current_page = {
                    "Name": page_name,
                    "Description": "",
                    "Requirements": []
                }
                brd_dict["BusinessRequirementsDocument"]["FunctionalRequirements"]["StreamlituIPages"]["Page"].append(current_page)
                current_requirement = None
                in_column_specific = False

            i += 1
            continue

        # Content lines for page description
        if line.startswith('- **Description**') and current_page is not None:
            desc_parts = line.split(': ', 1)
            if len(desc_parts) > 1:
                current_page["Description"] = desc_parts[1].strip()

            i += 1
            continue

        # Check for "Column-Specific Processing:" line
        if line == "- Column-Specific Processing:" and current_page is not None:
            in_column_specific = True
            requirement = {"Requirement": line[2:].strip(), "Conditions": []}
            current_page["Requirements"].append(requirement)
            current_requirement = requirement
            i += 1
            continue

        # Requirements (bullet points)
        if line.startswith('- ') and current_page is not None and not line.startswith('- **'):
            in_column_specific = False  # Reset when we hit a new requirement
            requirement_text = line[2:].strip()
            requirement = {"Requirement": requirement_text, "Conditions": []}
            current_page["Requirements"].append(requirement)
            current_requirement = requirement

            i += 1
            continue

        # Conditions (sub-bullet points)
        if line.startswith('    - ') and current_requirement is not None:
            condition_text = line[6:].strip()
            current_requirement["Conditions"].append(condition_text)

            i += 1
            continue

        # Libraries
        if line.startswith('- `') and in_libraries:
            library = line[3:].strip().strip('`')
            brd_dict["BusinessRequirementsDocument"]["LibrariesToUse"]["Library"].append(library)

            i += 1
            continue

        # If none of the above conditions match, move to the next line
        i += 1

    # Post-processing: fix the structure for pages and requirements
    pages = brd_dict["BusinessRequirementsDocument"]["FunctionalRequirements"]["StreamlituIPages"]["Page"]
    for page in pages:
        new_requirements = []
        for req in page["Requirements"]:
            if req["Conditions"]:
                # This requirement has conditions
                new_req = {
                    "Requirement": req["Requirement"],
                    "Condition": [{"Condition": cond} for cond in req["Conditions"]]
                }
                new_requirements.append(new_req)
            else:
                # This requirement has no conditions
                new_requirements.append({"Requirement": req["Requirement"]})

        page["Requirements"] = {"Requirement": new_requirements}

    return brd_dict

def dict_to_xml(dict_data):
    """Convert dictionary to XML."""
    root = ET.Element("BusinessRequirementsDocument")

    # Add simple elements
    for key in ["Project", "Version", "Date", "Author", "Stakeholders"]:
        if key in dict_data["BusinessRequirementsDocument"]:
            element = ET.SubElement(root, key)
            element.text = dict_data["BusinessRequirementsDocument"][key]

    # Add Overview
    if "Overview" in dict_data["BusinessRequirementsDocument"]:
        overview = ET.SubElement(root, "Overview")
        description = ET.SubElement(overview, "Description")
        description.text = dict_data["BusinessRequirementsDocument"]["Overview"]["Description"]

    # Add Functional Requirements
    if "FunctionalRequirements" in dict_data["BusinessRequirementsDocument"]:
        func_reqs = ET.SubElement(root, "FunctionalRequirements")

        # Add Menu Title
        if "MenuTitle" in dict_data["BusinessRequirementsDocument"]["FunctionalRequirements"]:
            menu_title = ET.SubElement(func_reqs, "MenuTitle")
            menu_title.text = dict_data["BusinessRequirementsDocument"]["FunctionalRequirements"]["MenuTitle"]

        # Add Streamlit UI Pages
        if "StreamlituIPages" in dict_data["BusinessRequirementsDocument"]["FunctionalRequirements"]:
            ui_pages = ET.SubElement(func_reqs, "StreamlituIPages")

            # Add Pages
            for page_data in dict_data["BusinessRequirementsDocument"]["FunctionalRequirements"]["StreamlituIPages"]["Page"]:
                page = ET.SubElement(ui_pages, "Page")

                # Add Page Name
                name = ET.SubElement(page, "Name")
                name.text = page_data["Name"]

                # Add Page Description
                description = ET.SubElement(page, "Description")
                description.text = page_data["Description"]

                # Add Requirements
                requirements = ET.SubElement(page, "Requirements")

                for req_data in page_data["Requirements"]["Requirement"]:
                    requirement = ET.SubElement(requirements, "Requirement")

                    if isinstance(req_data, dict) and "Requirement" in req_data:
                        requirement.text = req_data["Requirement"]

                        # Add Conditions if present
                        if "Condition" in req_data:
                            for condition_data in req_data["Condition"]:
                                condition = ET.SubElement(requirement, "Condition")
                                condition.text = condition_data["Condition"]
                    else:
                        requirement.text = req_data

    # Add Libraries to Use
    if "LibrariesToUse" in dict_data["BusinessRequirementsDocument"]:
        libraries = ET.SubElement(root, "LibrariesToUse")

        for lib in dict_data["BusinessRequirementsDocument"]["LibrariesToUse"]["Library"]:
            library = ET.SubElement(libraries, "Library")
            library.text = lib

    # Convert to string and pretty print
    rough_string = ET.tostring(root, 'utf-8')
    reparsed = xml.dom.minidom.parseString(rough_string)
    return reparsed.toprettyxml(indent="\t")

def main():
    # Find the BRD markdown file in the current directory
    brd_files = [f for f in os.listdir('.') if f.endswith('.md') and 'BRD' in f.upper()]

    if not brd_files:
        print("No BRD markdown file found in the current directory.")
        return

    brd_file = brd_files[0]
    print(f"Processing {brd_file}...")

    # Read markdown content
    markdown_content = read_markdown_file(brd_file)

    # Parse markdown to dictionary
    brd_dict = parse_markdown_to_dict(markdown_content)

    # Save JSON file
    json_file = brd_file.replace('.md', '.json')
    with open(json_file, 'w', encoding='utf-8') as f:
        json.dump(brd_dict, f, indent=2)
    print(f"JSON file saved as {json_file}")

    # Convert dictionary to XML
    xml_content = dict_to_xml(brd_dict)

    # Save XML file
    xml_file = brd_file.replace('.md', '.xml')
    with open(xml_file, 'w', encoding='utf-8') as f:
        f.write(xml_content)
    print(f"XML file saved as {xml_file}")

if __name__ == "__main__":
    main()

# Created/Modified files during execution:
# BRD.json
# BRD.xml

``````````````````````````
import re
import json
import xml.dom.minidom
import xml.etree.ElementTree as ET
import os

def read_markdown_file(file_path):
    """Read the markdown file content."""
    with open(file_path, 'r', encoding='utf-8') as file:
        return file.read()

def parse_markdown_to_dict(markdown_content):
    """Parse markdown content to a structured dictionary."""
    lines = markdown_content.split('\n')
    brd_dict = {
        "BusinessRequirementsDocument": {
            "Project": "",
            "Version": "",
            "Date": "",
            "Author": "",
            "Stakeholders": "",
            "Overview": {
                "Description": ""
            },
            "FunctionalRequirements": {
                "MenuTitle": "",
                "StreamlituIPages": {
                    "Page": []
                }
            },
            "LibrariesToUse": {
                "Library": []
            }
        }
    }

    current_section = None
    current_subsection = None
    current_page = None
    current_requirement = None
    in_libraries = False

    i = 0
    while i < len(lines):
        line = lines[i].strip()

        # Skip empty lines
        if not line:
            i += 1
            continue

        # Main sections (h1)
        if line.startswith('# '):
            current_section = line[2:].strip()
            current_subsection = None
            current_page = None
            current_requirement = None
            in_libraries = False
            i += 1
            continue

        # Subsections (h2)
        if line.startswith('## '):
            current_subsection = line[3:].strip()
            current_page = None
            current_requirement = None

            # Check next line for content
            next_line_index = i + 1
            while next_line_index < len(lines) and not lines[next_line_index].strip():
                next_line_index += 1

            if next_line_index < len(lines):
                next_line = lines[next_line_index].strip()

                if current_subsection == "Project":
                    if next_line.startswith('- **'):
                        value = next_line.split('**:', 1)[1].strip() if '**:' in next_line else next_line.split('**', 2)[1].strip()
                        brd_dict["BusinessRequirementsDocument"]["Project"] = value
                elif current_subsection == "Version":
                    if next_line.startswith('- **'):
                        value = next_line.split('**:', 1)[1].strip() if '**:' in next_line else next_line.split('**', 2)[1].strip()
                        brd_dict["BusinessRequirementsDocument"]["Version"] = value
                elif current_subsection == "Date":
                    if next_line.startswith('- **'):
                        value = next_line.split('**:', 1)[1].strip() if '**:' in next_line else next_line.split('**', 2)[1].strip()
                        brd_dict["BusinessRequirementsDocument"]["Date"] = value
                elif current_subsection == "Author":
                    if next_line.startswith('- **'):
                        value = next_line.split('**:', 1)[1].strip() if '**:' in next_line else next_line.split('**', 2)[1].strip()
                        brd_dict["BusinessRequirementsDocument"]["Author"] = value
                elif current_subsection == "Stakeholders":
                    if next_line.startswith('- **'):
                        value = next_line.split('**:', 1)[1].strip() if '**:' in next_line else next_line.split('**', 2)[1].strip()
                        brd_dict["BusinessRequirementsDocument"]["Stakeholders"] = value
                elif current_subsection == "Overview":
                    if next_line.startswith('- **Description**'):
                        desc_line = next_line.split(': ', 1)
                        if len(desc_line) > 1:
                            brd_dict["BusinessRequirementsDocument"]["Overview"]["Description"] = desc_line[1].strip()
                elif current_subsection == "Functional Requirements":
                    current_subsection = "FunctionalRequirements"
                elif current_subsection == "Libraries to Use":
                    in_libraries = True

            i += 1
            continue

        # Sub-subsections (h3)
        if line.startswith('### '):
            subsub_section = line[4:].strip()
            if current_subsection == "FunctionalRequirements":
                if subsub_section == "Menu Title":
                    # Check next line for content
                    next_line_index = i + 1
                    while next_line_index < len(lines) and not lines[next_line_index].strip():
                        next_line_index += 1

                    if next_line_index < len(lines):
                        next_line = lines[next_line_index].strip()
                        if next_line.startswith('- **'):
                            value = next_line.split('**:', 1)[1].strip() if '**:' in next_line else next_line.split('**', 2)[1].strip()
                            brd_dict["BusinessRequirementsDocument"]["FunctionalRequirements"]["MenuTitle"] = value
                elif subsub_section == "Streamlit UI Pages":
                    current_subsection = "StreamlituIPages"

            i += 1
            continue

        # Sub-sub-subsections (h4)
        if line.startswith('#### '):
            page_name = line[5:].strip()
            if current_subsection == "StreamlituIPages":
                current_page = {
                    "Name": page_name,
                    "Description": "",
                    "Requirements": []
                }
                brd_dict["BusinessRequirementsDocument"]["FunctionalRequirements"]["StreamlituIPages"]["Page"].append(current_page)
                current_requirement = None

            i += 1
            continue

        # Content lines for page description
        if line.startswith('- **Description**') and current_page is not None:
            desc_parts = line.split(': ', 1)
            if len(desc_parts) > 1:
                current_page["Description"] = desc_parts[1].strip()

            i += 1
            continue

        # Requirements (bullet points)
        if line.startswith('- ') and current_page is not None and not line.startswith('- **'):
            requirement_text = line[2:].strip()
            requirement = {"Requirement": requirement_text, "Conditions": []}
            current_page["Requirements"].append(requirement)
            current_requirement = requirement

            i += 1
            continue

        # Conditions (sub-bullet points)
        if line.startswith('    - ') and current_requirement is not None:
            condition_text = line[6:].strip()
            current_requirement["Conditions"].append(condition_text)

            i += 1
            continue

        # Libraries
        if line.startswith('- `') and in_libraries:
            library = line[3:].strip().strip('`')
            brd_dict["BusinessRequirementsDocument"]["LibrariesToUse"]["Library"].append(library)

            i += 1
            continue

        # If none of the above conditions match, move to the next line
        i += 1

    return brd_dict

def dict_to_xml(dict_data):
    """Convert dictionary to XML."""
    root = ET.Element("BusinessRequirementsDocument")

    # Add simple elements
    for key in ["Project", "Version", "Date", "Author", "Stakeholders"]:
        if key in dict_data["BusinessRequirementsDocument"]:
            element = ET.SubElement(root, key)
            element.text = dict_data["BusinessRequirementsDocument"][key]

    # Add Overview
    if "Overview" in dict_data["BusinessRequirementsDocument"]:
        overview = ET.SubElement(root, "Overview")
        description = ET.SubElement(overview, "Description")
        description.text = dict_data["BusinessRequirementsDocument"]["Overview"]["Description"]

    # Add Functional Requirements
    if "FunctionalRequirements" in dict_data["BusinessRequirementsDocument"]:
        func_reqs = ET.SubElement(root, "FunctionalRequirements")

        # Add Menu Title
        if "MenuTitle" in dict_data["BusinessRequirementsDocument"]["FunctionalRequirements"]:
            menu_title = ET.SubElement(func_reqs, "MenuTitle")
            menu_title.text = dict_data["BusinessRequirementsDocument"]["FunctionalRequirements"]["MenuTitle"]

        # Add Streamlit UI Pages
        if "StreamlituIPages" in dict_data["BusinessRequirementsDocument"]["FunctionalRequirements"]:
            ui_pages = ET.SubElement(func_reqs, "StreamlituIPages")

            # Add Pages
            for page_data in dict_data["BusinessRequirementsDocument"]["FunctionalRequirements"]["StreamlituIPages"]["Page"]:
                page = ET.SubElement(ui_pages, "Page")

                # Add Page Name
                name = ET.SubElement(page, "Name")
                name.text = page_data["Name"]

                # Add Page Description
                description = ET.SubElement(page, "Description")
                description.text = page_data["Description"]

                # Add Requirements
                requirements = ET.SubElement(page, "Requirements")

                for req_data in page_data["Requirements"]:
                    requirement = ET.SubElement(requirements, "Requirement")
                    requirement.text = req_data["Requirement"]

                    # Add Conditions if present
                    if req_data["Conditions"]:
                        for condition in req_data["Conditions"]:
                            condition_element = ET.SubElement(requirement, "Condition")
                            condition_element.text = condition

    # Add Libraries to Use
    if "LibrariesToUse" in dict_data["BusinessRequirementsDocument"]:
        libraries = ET.SubElement(root, "LibrariesToUse")

        for lib in dict_data["BusinessRequirementsDocument"]["LibrariesToUse"]["Library"]:
            library = ET.SubElement(libraries, "Library")
            library.text = lib

    # Convert to string and pretty print
    rough_string = ET.tostring(root, 'utf-8')
    reparsed = xml.dom.minidom.parseString(rough_string)
    return reparsed.toprettyxml(indent="\t")

def main():
    # Find the BRD markdown file in the current directory
    brd_files = [f for f in os.listdir('.') if f.endswith('.md') and 'BRD' in f.upper()]

    if not brd_files:
        print("No BRD markdown file found in the current directory.")
        return

    brd_file = brd_files[0]
    print(f"Processing {brd_file}...")

    # Read markdown content
    markdown_content = read_markdown_file(brd_file)

    # Parse markdown to dictionary
    brd_dict = parse_markdown_to_dict(markdown_content)

    # Save JSON file
    json_file = brd_file.replace('.md', '.json')
    with open(json_file, 'w', encoding='utf-8') as f:
        json.dump(brd_dict, f, indent=2)
    print(f"JSON file saved as {json_file}")

    # Convert dictionary to XML
    xml_content = dict_to_xml(brd_dict)

    # Save XML file
    xml_file = brd_file.replace('.md', '.xml')
    with open(xml_file, 'w', encoding='utf-8') as f:
        f.write(xml_content)
    print(f"XML file saved as {xml_file}")

if __name__ == "__main__":
    main()

# Created/Modified files during execution:
# BRD.json
# BRD.xml

````````````

import re
import json
import xml.dom.minidom
import xml.etree.ElementTree as ET
import os

def read_markdown_file(file_path):
    """Read the markdown file content."""
    with open(file_path, 'r', encoding='utf-8') as file:
        return file.read()

def parse_markdown_to_dict(markdown_content):
    """Parse markdown content to a structured dictionary."""
    lines = markdown_content.split('\n')
    brd_dict = {
        "BusinessRequirementsDocument": {
            "Project": "",
            "Version": "",
            "Date": "",
            "Author": "",
            "Stakeholders": "",
            "Overview": {
                "Description": ""
            },
            "FunctionalRequirements": {
                "MenuTitle": "",
                "StreamlituIPages": {
                    "Page": []
                }
            },
            "LibrariesToUse": {
                "Library": []
            }
        }
    }

    current_section = None
    current_subsection = None
    current_page = None
    current_requirement = None
    in_libraries = False

    i = 0
    while i < len(lines):
        line = lines[i].strip()

        # Skip empty lines
        if not line:
            i += 1
            continue

        # Main sections (h1)
        if line.startswith('# '):
            current_section = line[2:].strip()
            current_subsection = None
            current_page = None
            current_requirement = None
            in_libraries = False
            i += 1
            continue

        # Subsections (h2)
        if line.startswith('## '):
            current_subsection = line[3:].strip()
            current_page = None
            current_requirement = None

            # Check next line for content
            next_line_index = i + 1
            while next_line_index < len(lines) and not lines[next_line_index].strip():
                next_line_index += 1

            if next_line_index < len(lines):
                next_line = lines[next_line_index].strip()

                if current_subsection == "Project":
                    if next_line.startswith('- **'):
                        value = next_line.split('**:', 1)[1].strip() if '**:' in next_line else next_line.split('**', 2)[1].strip()
                        brd_dict["BusinessRequirementsDocument"]["Project"] = value
                elif current_subsection == "Version":
                    if next_line.startswith('- **'):
                        value = next_line.split('**:', 1)[1].strip() if '**:' in next_line else next_line.split('**', 2)[1].strip()
                        brd_dict["BusinessRequirementsDocument"]["Version"] = value
                elif current_subsection == "Date":
                    if next_line.startswith('- **'):
                        value = next_line.split('**:', 1)[1].strip() if '**:' in next_line else next_line.split('**', 2)[1].strip()
                        brd_dict["BusinessRequirementsDocument"]["Date"] = value
                elif current_subsection == "Author":
                    if next_line.startswith('- **'):
                        value = next_line.split('**:', 1)[1].strip() if '**:' in next_line else next_line.split('**', 2)[1].strip()
                        brd_dict["BusinessRequirementsDocument"]["Author"] = value
                elif current_subsection == "Stakeholders":
                    if next_line.startswith('- **'):
                        value = next_line.split('**:', 1)[1].strip() if '**:' in next_line else next_line.split('**', 2)[1].strip()
                        brd_dict["BusinessRequirementsDocument"]["Stakeholders"] = value
                elif current_subsection == "Overview":
                    if next_line.startswith('- **Description**'):
                        desc_line = next_line.split(': ', 1)
                        if len(desc_line) > 1:
                            brd_dict["BusinessRequirementsDocument"]["Overview"]["Description"] = desc_line[1].strip()
                elif current_subsection == "Functional Requirements":
                    current_subsection = "FunctionalRequirements"
                elif current_subsection == "Libraries to Use":
                    in_libraries = True

            i += 1
            continue

        # Sub-subsections (h3)
        if line.startswith('### '):
            subsub_section = line[4:].strip()
            if current_subsection == "FunctionalRequirements":
                if subsub_section == "Menu Title":
                    # Check next line for content
                    next_line_index = i + 1
                    while next_line_index < len(lines) and not lines[next_line_index].strip():
                        next_line_index += 1

                    if next_line_index < len(lines):
                        next_line = lines[next_line_index].strip()
                        if next_line.startswith('- **'):
                            value = next_line.split('**:', 1)[1].strip() if '**:' in next_line else next_line.split('**', 2)[1].strip()
                            brd_dict["BusinessRequirementsDocument"]["FunctionalRequirements"]["MenuTitle"] = value
                elif subsub_section == "Streamlit UI Pages":
                    current_subsection = "StreamlituIPages"

            i += 1
            continue

        # Sub-sub-subsections (h4)
        if line.startswith('#### '):
            page_name = line[5:].strip()
            if current_subsection == "StreamlituIPages":
                current_page = {
                    "Name": page_name,
                    "Description": "",
                    "Requirements": []
                }
                brd_dict["BusinessRequirementsDocument"]["FunctionalRequirements"]["StreamlituIPages"]["Page"].append(current_page)
                current_requirement = None

            i += 1
            continue

        # Content lines for page description
        if line.startswith('- **Description**') and current_page is not None:
            desc_parts = line.split(': ', 1)
            if len(desc_parts) > 1:
                current_page["Description"] = desc_parts[1].strip()

            i += 1
            continue

        # Requirements (bullet points)
        if line.startswith('- ') and current_page is not None and not line.startswith('- **'):
            requirement_text = line[2:].strip()
            requirement = {"Requirement": requirement_text, "Conditions": []}
            current_page["Requirements"].append(requirement)
            current_requirement = requirement

            i += 1
            continue

        # Conditions (sub-bullet points)
        if line.startswith('    - ') and current_requirement is not None:
            condition_text = line[6:].strip()
            current_requirement["Conditions"].append(condition_text)

            i += 1
            continue

        # Libraries
        if line.startswith('- `') and in_libraries:
            library = line[3:].strip().strip('`')
            brd_dict["BusinessRequirementsDocument"]["LibrariesToUse"]["Library"].append(library)

            i += 1
            continue

        # If none of the above conditions match, move to the next line
        i += 1

    return brd_dict

def dict_to_xml(dict_data):
    """Convert dictionary to XML."""
    root = ET.Element("BusinessRequirementsDocument")

    # Add simple elements
    for key in ["Project", "Version", "Date", "Author", "Stakeholders"]:
        if key in dict_data["BusinessRequirementsDocument"]:
            element = ET.SubElement(root, key)
            element.text = dict_data["BusinessRequirementsDocument"][key]

    # Add Overview
    if "Overview" in dict_data["BusinessRequirementsDocument"]:
        overview = ET.SubElement(root, "Overview")
        description = ET.SubElement(overview, "Description")
        description.text = dict_data["BusinessRequirementsDocument"]["Overview"]["Description"]

    # Add Functional Requirements
    if "FunctionalRequirements" in dict_data["BusinessRequirementsDocument"]:
        func_reqs = ET.SubElement(root, "FunctionalRequirements")

        # Add Menu Title
        if "MenuTitle" in dict_data["BusinessRequirementsDocument"]["FunctionalRequirements"]:
            menu_title = ET.SubElement(func_reqs, "MenuTitle")
            menu_title.text = dict_data["BusinessRequirementsDocument"]["FunctionalRequirements"]["MenuTitle"]

        # Add Streamlit UI Pages
        if "StreamlituIPages" in dict_data["BusinessRequirementsDocument"]["FunctionalRequirements"]:
            ui_pages = ET.SubElement(func_reqs, "StreamlituIPages")

            # Add Pages
            for page_data in dict_data["BusinessRequirementsDocument"]["FunctionalRequirements"]["StreamlituIPages"]["Page"]:
                page = ET.SubElement(ui_pages, "Page")

                # Add Page Name
                name = ET.SubElement(page, "Name")
                name.text = page_data["Name"]

                # Add Page Description
                description = ET.SubElement(page, "Description")
                description.text = page_data["Description"]

                # Add Requirements
                requirements = ET.SubElement(page, "Requirements")

                for req_data in page_data["Requirements"]:
                    requirement = ET.SubElement(requirements, "Requirement")
                    requirement.text = req_data["Requirement"]

                    # Add Conditions if present
                    if req_data["Conditions"]:
                        for condition in req_data["Conditions"]:
                            condition_element = ET.SubElement(requirement, "Condition")
                            condition_element.text = condition

    # Add Libraries to Use
    if "LibrariesToUse" in dict_data["BusinessRequirementsDocument"]:
        libraries = ET.SubElement(root, "LibrariesToUse")

        for lib in dict_data["BusinessRequirementsDocument"]["LibrariesToUse"]["Library"]:
            library = ET.SubElement(libraries, "Library")
            library.text = lib

    # Convert to string and pretty print
    rough_string = ET.tostring(root, 'utf-8')
    reparsed = xml.dom.minidom.parseString(rough_string)
    return reparsed.toprettyxml(indent="\t")

def main():
    # Find the BRD markdown file in the current directory
    brd_files = [f for f in os.listdir('.') if f.endswith('.md') and 'BRD' in f.upper()]

    if not brd_files:
        print("No BRD markdown file found in the current directory.")
        return

    brd_file = brd_files[0]
    print(f"Processing {brd_file}...")

    # Read markdown content
    markdown_content = read_markdown_file(brd_file)

    # Parse markdown to dictionary
    brd_dict = parse_markdown_to_dict(markdown_content)

    # Save JSON file
    json_file = brd_file.replace('.md', '.json')
    with open(json_file, 'w', encoding='utf-8') as f:
        json.dump(brd_dict, f, indent=2)
    print(f"JSON file saved as {json_file}")

    # Convert dictionary to XML
    xml_content = dict_to_xml(brd_dict)

    # Save XML file
    xml_file = brd_file.replace('.md', '.xml')
    with open(xml_file, 'w', encoding='utf-8') as f:
        f.write(xml_content)
    print(f"XML file saved as {xml_file}")

if __name__ == "__main__":
    main()

# Created/Modified files during execution:
# BRD.json
# BRD.xml
